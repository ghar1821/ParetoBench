library('devtools')
if(!require('Spectre')) {install_github("sydneycytometry/spectre")}
clus_algo_data <- read.csv("/Users/givanna/dropbox/lweber_dataset/flowsom/Mosmann_rare/Output_CAPX_seed32/Output-data/Clustered_FlowSOM_Param1.csv")
clus_truth_data <- read.csv("/Users/givanna/dropbox/lweber_dataset/dataset/normalised_csv/Mosmann_rare.csv")
View(clus_algo_data)
View(clus_algo_data)
clus_algorithm <- clus_algo_data[, "FlowSOM_metacluster"]
clus_truth <- clus_truth_data[, "label"]
View(clus_truth_data)
clus_truth <- clus_truth_data[, "TrueLabel"]
# number of detected clusters
n_clus <- length(table(clus_algorithm))
tbl_algorithm <- table(clus_algorithm)
View(clus_algo_data)
tbl_truth <- table(clus_truth)
cost_mat <- matrix(NA, nrow = length(tbl_algorithm), ncol = 1)
i <- 1
i_int <- as.integer(names(tbl_algorithm))[i]  # cluster number from algorithm
j_int <- 1  # true cluster number of the rare population of interest
cost_ij <- sum(clus_algorithm == i_int & clus_truth == j_int, na.rm = TRUE)
cost_mat[i, j_int] <- cost_ij
for (i in 1:length(tbl_algorithm)) {
i_int <- as.integer(names(tbl_algorithm))[i]  # cluster number from algorithm
j_int <- 1  # true cluster number of the rare population of interest
cost_ij <- sum(clus_algorithm == i_int & clus_truth == j_int, na.rm = TRUE)
cost_mat[i, j_int] <- cost_ij
}
cost_mat
# put back cluster labels (note some row names may be missing due to removal of unassigned cells)
rownames(cost_mat) <- names(tbl_algorithm)
colnames(cost_mat) <- "1"  # one column only
cost_mat
# match label (single cluster only) using highest F1 score
# use row names since some labels may have been removed due to unassigned cells
labels_matched <- as.numeric(rownames(cost_mat)[apply(cost_mat, 2, which.max)])
labels_matched
names(labels_matched) <- "1"  # one column only
labels_matched
# precision, recall, F1 score, and number of cells for single matched cluster
# use character names for row and column indices in case subsampling completely removes some clusters
cost <- cost_mat[as.character(labels_matched), "1"]
cost
clus_truth == j_int
sum(clus_truth == j_int)
n_cells_matched <- sum(clus_algorithm == labels_matched, na.rm = TRUE)
cost
accuracy <- cost / sum(clus_truth == j_int)
cost_mat
accuracy
n_cells_matched
clus_algorithm == labels_matched
# for calculating F-measure of examples in paper
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
source('helper_match_evaluate_multiple.R')
### to ensure that F-measure capture clustering that poorly captures rare items
clus_truth <- vector("list", 1)
names(clus_truth) <- c('poor')
# 1=B cell, 2=PDC
clus_truth[['poor']] <- c(rep(1,5000), rep(2,10))
clus <- vector("list", 1)
names(clus) <- c('oor')
clus[['poor']] <- c(rep(1,3000), rep(2,2000), rep(1,7), rep(2,3))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,3000), rep(2,2000), rep(1,7), rep(2,3))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
View(res)
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,9950), rep(2,50), rep(1,9), rep(2,1))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
# for calculating F-measure of examples in paper
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
source('helper_match_evaluate_multiple.R')
### to ensure that F-measure capture clustering that poorly captures rare items
clus_truth <- vector("list", 1)
names(clus_truth) <- c('poor')
# 1=B cell, 2=PDC
clus_truth[['poor']] <- c(rep(1,10000), rep(2,10))
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,9950), rep(2,50), rep(1,9), rep(2,1))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
N <- 100000
n <- 10
d <- matrix(rnorm(N*n), nrow=10)
m <- colMeans(d)
s <- apply(d, 2, sd)
hist(s, 10000)
library(data.table)
# generate B cell data
N <- 100000
n <- 10
d <- matrix(rnorm(N*n), nrow=10)
m <- colMeans(d)
b.cell <- apply(d, 2, sd)
data = data.table(marker1=b.cell, marker2=b.cell)
b.cell.data = data.table(marker1=b.cell, marker2=b.cell)
# generate PDC data
N <- 10
n <- 10
d <- matrix(rnorm(N*n), nrow=10)
m <- colMeans(d)
pdc <- apply(d, 2, sd)
hist(pdc, 10000)
pdc.cell.data = data.table(marker1=pdc, marker2=pdc)
pdc <- pdc + 10
pdc
pdc.cell.data = data.table(marker1=pdc, marker2=pdc)
# merge them
data <- data.table(marker1=c(b.cell, pdc), marker2=c(b.cell, pdc))
data
library(Spectre)
# merge them
cell.dat <- data.table(marker1=c(b.cell, pdc), marker2=c(b.cell, pdc))
Spectre::make.density.plot(dat = cell.dat,
x.axis = "marker1",
y.axis = "marker2",
save.to.disk = FALSE)
# generate B cell data
set.seed(42)
b.cell.x <- sample(seq(100,500), 10000)
b.cell.x <- sample(seq(100,500), 10000, replace = T)
b.cell.y <- sample(seq(100,500), 10000, replace = T)
# generate PDC data
pdc.cell.x <- sample(seq(600,700), 10)
pdc.cell.y <- sample(seq(600,700), 10)
# merge them
cell.dat <- data.table(marker1=c(b.cell,x, pdc.cell.x), marker2=c(b.cell.y, pdc.cell.y))
# merge them
cell.dat <- data.table(marker1=c(b.cell.x, pdc.cell.x), marker2=c(b.cell.y, pdc.cell.y))
Spectre::make.density.plot(dat = cell.dat,
x.axis = "marker1",
y.axis = "marker2",
save.to.disk = FALSE)
b.cell.x <- sample(seq(100,200), 10000, replace = T)
b.cell.y <- sample(seq(100,200), 10000, replace = T)
# generate PDC data
pdc.cell.x <- sample(seq(600,700), 10)
pdc.cell.y <- sample(seq(600,700), 10)
# merge them
cell.dat <- data.table(marker1=c(b.cell.x, pdc.cell.x), marker2=c(b.cell.y, pdc.cell.y))
Spectre::make.density.plot(dat = cell.dat,
x.axis = "marker1",
y.axis = "marker2",
save.to.disk = FALSE)
b.cell.x <- sample(seq(100,200), 10000, replace = T)
b.cell.y <- sample(seq(50,200), 10000, replace = T)
# generate PDC data
pdc.cell.x <- sample(seq(200,250), 10)
pdc.cell.y <- sample(seq(200,250), 10)
# merge them
cell.dat <- data.table(marker1=c(b.cell.x, pdc.cell.x), marker2=c(b.cell.y, pdc.cell.y))
Spectre::make.density.plot(dat = cell.dat,
x.axis = "marker1",
y.axis = "marker2",
save.to.disk = FALSE)
View(res)
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,9900), rep(2,100), rep(1,9), rep(2,1))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,9950), rep(2,50), rep(1,9), rep(2,1))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
for (i in 1:length(clus)) {
res[[i]] <- helper_match_evaluate_multiple(clus[[i]], clus_truth[[i]])
}
View(res)
# for calculating F-measure of examples in paper
dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
getwd()
# perfect, over, and under clustering
clus_truth <- vector("list", 3)
names(clus_truth) <- c('perfect', 'over', 'under')
# 1=sun, 2=tree, 3=bone
clus_truth[['perfect']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['over']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['under']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
### to ensure that F-measure capture clustering that poorly captures rare items
clus_truth <- vector("list", 1)
names(clus_truth) <- c('poor')
# 1=B cell, 2=PDC
clus_truth[['poor']] <- c(rep(1,10000), rep(2,10))
clus <- vector("list", 1)
names(clus) <- c('poor')
clus[['poor']] <- c(rep(1,9950), rep(2,50), rep(1,9), rep(2,1))
res <- vector("list", 1)
names(res)[1:length(clus)] <- names(clus)
clus_algorithm <- clus[[1]]
clus_truth <- clus_truth[[1]]
# number of detected clusters
n_clus <- length(table(clus_algorithm))
# re-assign unassigned cells as -1
# do this if you want calculation to include unassigned cells
clus_truth[is.na(clus_truth)] <- -1
if (length(clus_algorithm) != length(clus_truth)) warning("vector lengths are not equal")
tbl_algorithm <- table(clus_algorithm)
tbl_truth <- table(clus_truth)
# detected clusters in rows, true populations in columns
pr_mat <- re_mat <- F1_mat <- matrix(NA, nrow = length(tbl_algorithm), ncol = length(tbl_truth))
for (i in 1:length(tbl_algorithm)) {
for (j in 1:length(tbl_truth)) {
i_int <- as.integer(names(tbl_algorithm))[i]  # cluster number from algorithm
j_int <- as.integer(names(tbl_truth))[j]  # cluster number from true labels
true_positives <- sum(clus_algorithm == i_int & clus_truth == j_int, na.rm = TRUE)
detected <- sum(clus_algorithm == i_int, na.rm = TRUE)
truth <- sum(clus_truth == j_int, na.rm = TRUE)
# calculate precision, recall, and F1 score
precision_ij <- true_positives / detected
recall_ij <- true_positives / truth
F1_ij <- 2 * (precision_ij * recall_ij) / (precision_ij + recall_ij)
if (F1_ij == "NaN") F1_ij <- 0
pr_mat[i, j] <- precision_ij
re_mat[i, j] <- recall_ij
F1_mat[i, j] <- F1_ij
}
}
# put back cluster labels (note some row names may be missing due to removal of unassigned cells)
rownames(pr_mat) <- rownames(re_mat) <- rownames(F1_mat) <- names(tbl_algorithm)
colnames(pr_mat) <- colnames(re_mat) <- colnames(F1_mat) <- names(tbl_truth)
# use transpose matrix (Hungarian algorithm assumes n_rows <= n_cols)
F1_mat_trans <- t(F1_mat)
if (nrow(F1_mat_trans) <= ncol(F1_mat_trans)) {
# if fewer (or equal no.) true populations than detected clusters, can match all true populations
labels_matched <- clue::solve_LSAP(F1_mat_trans, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched <- as.numeric(colnames(F1_mat_trans)[as.numeric(labels_matched)])
names(labels_matched) <- rownames(F1_mat_trans)
} else {
# if fewer detected clusters than true populations, use transpose matrix and assign
# NAs for true populations without any matching clusters
labels_matched_flipped <- clue::solve_LSAP(F1_mat, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched_flipped <- as.numeric(rownames(F1_mat_trans)[as.numeric(labels_matched_flipped)])
names(labels_matched_flipped) <- rownames(F1_mat)
labels_matched <- rep(NA, ncol(F1_mat))
names(labels_matched) <- rownames(F1_mat_trans)
labels_matched[as.character(labels_matched_flipped)] <- as.numeric(names(labels_matched_flipped))
}
# precision, recall, F1 score, and number of cells for each matched cluster
pr <- re <- F1 <- n_cells_matched <- rep(NA, ncol(F1_mat))
names(pr) <- names(re) <- names(F1) <- names(n_cells_matched) <- names(labels_matched)
for (i in 1:ncol(F1_mat)) {
# set to 0 if no matching cluster (too few detected clusters); use character names
# for row and column indices in case subsampling completely removes some clusters
pr[i] <- ifelse(is.na(labels_matched[i]), 0, pr_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
re[i] <- ifelse(is.na(labels_matched[i]), 0, re_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
F1[i] <- ifelse(is.na(labels_matched[i]), 0, F1_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
n_cells_matched[i] <- sum(clus_algorithm == labels_matched[i], na.rm = TRUE)
}
pr
# perfect, over, and under clustering
clus_truth <- vector("list", 3)
names(clus_truth) <- c('perfect', 'over', 'under')
# 1=sun, 2=tree, 3=bone
clus_truth[['perfect']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['over']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['under']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus <- vector("list", 3)
names(clus) <- c('perfect', 'over', 'under')
clus[['perfect']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus[['over']] <- c(1,1,4,4,4,2,2,5,5,3,3,6,6)
clus[['under']] <- c(1,1,1,1,1,2,2,2,2,1,1,2,2)
clus_algorithm <- clus[[3]]
clus_truth <- clus_truth[[3]]
n_clus <- length(table(clus_algorithm))
# remove unassigned cells (NA's in clus_truth)
#unassigned <- is.na(clus_truth)
#clus_algorithm <- clus_algorithm[!unassigned]
#clus_truth <- clus_truth[!unassigned]
# re-assign unassigned cells as -1
# do this if you want calculation to include unassigned cells
clus_truth[is.na(clus_truth)] <- -1
if (length(clus_algorithm) != length(clus_truth)) warning("vector lengths are not equal")
tbl_algorithm <- table(clus_algorithm)
tbl_truth <- table(clus_truth)
# detected clusters in rows, true populations in columns
pr_mat <- re_mat <- F1_mat <- matrix(NA, nrow = length(tbl_algorithm), ncol = length(tbl_truth))
for (i in 1:length(tbl_algorithm)) {
for (j in 1:length(tbl_truth)) {
i_int <- as.integer(names(tbl_algorithm))[i]  # cluster number from algorithm
j_int <- as.integer(names(tbl_truth))[j]  # cluster number from true labels
true_positives <- sum(clus_algorithm == i_int & clus_truth == j_int, na.rm = TRUE)
detected <- sum(clus_algorithm == i_int, na.rm = TRUE)
truth <- sum(clus_truth == j_int, na.rm = TRUE)
# calculate precision, recall, and F1 score
precision_ij <- true_positives / detected
recall_ij <- true_positives / truth
F1_ij <- 2 * (precision_ij * recall_ij) / (precision_ij + recall_ij)
if (F1_ij == "NaN") F1_ij <- 0
pr_mat[i, j] <- precision_ij
re_mat[i, j] <- recall_ij
F1_mat[i, j] <- F1_ij
}
}
# put back cluster labels (note some row names may be missing due to removal of unassigned cells)
rownames(pr_mat) <- rownames(re_mat) <- rownames(F1_mat) <- names(tbl_algorithm)
colnames(pr_mat) <- colnames(re_mat) <- colnames(F1_mat) <- names(tbl_truth)
# match labels using Hungarian algorithm applied to matrix of F1 scores (Hungarian
# algorithm calculates an optimal one-to-one assignment)
# use transpose matrix (Hungarian algorithm assumes n_rows <= n_cols)
F1_mat_trans <- t(F1_mat)
if (nrow(F1_mat_trans) <= ncol(F1_mat_trans)) {
# if fewer (or equal no.) true populations than detected clusters, can match all true populations
labels_matched <- clue::solve_LSAP(F1_mat_trans, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched <- as.numeric(colnames(F1_mat_trans)[as.numeric(labels_matched)])
names(labels_matched) <- rownames(F1_mat_trans)
} else {
# if fewer detected clusters than true populations, use transpose matrix and assign
# NAs for true populations without any matching clusters
labels_matched_flipped <- clue::solve_LSAP(F1_mat, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched_flipped <- as.numeric(rownames(F1_mat_trans)[as.numeric(labels_matched_flipped)])
names(labels_matched_flipped) <- rownames(F1_mat)
labels_matched <- rep(NA, ncol(F1_mat))
names(labels_matched) <- rownames(F1_mat_trans)
labels_matched[as.character(labels_matched_flipped)] <- as.numeric(names(labels_matched_flipped))
}
# precision, recall, F1 score, and number of cells for each matched cluster
pr <- re <- F1 <- n_cells_matched <- rep(NA, ncol(F1_mat))
names(pr) <- names(re) <- names(F1) <- names(n_cells_matched) <- names(labels_matched)
for (i in 1:ncol(F1_mat)) {
# set to 0 if no matching cluster (too few detected clusters); use character names
# for row and column indices in case subsampling completely removes some clusters
pr[i] <- ifelse(is.na(labels_matched[i]), 0, pr_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
re[i] <- ifelse(is.na(labels_matched[i]), 0, re_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
F1[i] <- ifelse(is.na(labels_matched[i]), 0, F1_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
n_cells_matched[i] <- sum(clus_algorithm == labels_matched[i], na.rm = TRUE)
}
pr
labels_matched
# means across populations
mean_pr <- mean(pr)
mean_re <- mean(re)
mean_F1 <- mean(F1)
mean_pr
mean_F1
# perfect, over, and under clustering
clus_truth <- vector("list", 3)
names(clus_truth) <- c('perfect', 'over', 'under')
# 1=sun, 2=tree, 3=bone
clus_truth[['perfect']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['over']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_truth[['under']] <- c(1,1,1,1,1,2,2,2,2,3,3,3,3)
clus_algorithm <- clus[[2]]
clus_truth <- clus_truth[[2]]
# number of detected clusters
n_clus <- length(table(clus_algorithm))
# remove unassigned cells (NA's in clus_truth)
#unassigned <- is.na(clus_truth)
#clus_algorithm <- clus_algorithm[!unassigned]
#clus_truth <- clus_truth[!unassigned]
# re-assign unassigned cells as -1
# do this if you want calculation to include unassigned cells
clus_truth[is.na(clus_truth)] <- -1
if (length(clus_algorithm) != length(clus_truth)) warning("vector lengths are not equal")
tbl_algorithm <- table(clus_algorithm)
tbl_truth <- table(clus_truth)
# detected clusters in rows, true populations in columns
pr_mat <- re_mat <- F1_mat <- matrix(NA, nrow = length(tbl_algorithm), ncol = length(tbl_truth))
for (i in 1:length(tbl_algorithm)) {
for (j in 1:length(tbl_truth)) {
i_int <- as.integer(names(tbl_algorithm))[i]  # cluster number from algorithm
j_int <- as.integer(names(tbl_truth))[j]  # cluster number from true labels
true_positives <- sum(clus_algorithm == i_int & clus_truth == j_int, na.rm = TRUE)
detected <- sum(clus_algorithm == i_int, na.rm = TRUE)
truth <- sum(clus_truth == j_int, na.rm = TRUE)
# calculate precision, recall, and F1 score
precision_ij <- true_positives / detected
recall_ij <- true_positives / truth
F1_ij <- 2 * (precision_ij * recall_ij) / (precision_ij + recall_ij)
if (F1_ij == "NaN") F1_ij <- 0
pr_mat[i, j] <- precision_ij
re_mat[i, j] <- recall_ij
F1_mat[i, j] <- F1_ij
}
}
# put back cluster labels (note some row names may be missing due to removal of unassigned cells)
rownames(pr_mat) <- rownames(re_mat) <- rownames(F1_mat) <- names(tbl_algorithm)
colnames(pr_mat) <- colnames(re_mat) <- colnames(F1_mat) <- names(tbl_truth)
# match labels using Hungarian algorithm applied to matrix of F1 scores (Hungarian
# algorithm calculates an optimal one-to-one assignment)
# use transpose matrix (Hungarian algorithm assumes n_rows <= n_cols)
F1_mat_trans <- t(F1_mat)
if (nrow(F1_mat_trans) <= ncol(F1_mat_trans)) {
# if fewer (or equal no.) true populations than detected clusters, can match all true populations
labels_matched <- clue::solve_LSAP(F1_mat_trans, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched <- as.numeric(colnames(F1_mat_trans)[as.numeric(labels_matched)])
names(labels_matched) <- rownames(F1_mat_trans)
} else {
# if fewer detected clusters than true populations, use transpose matrix and assign
# NAs for true populations without any matching clusters
labels_matched_flipped <- clue::solve_LSAP(F1_mat, maximum = TRUE)
# use row and column names since some labels may have been removed due to unassigned cells
labels_matched_flipped <- as.numeric(rownames(F1_mat_trans)[as.numeric(labels_matched_flipped)])
names(labels_matched_flipped) <- rownames(F1_mat)
labels_matched <- rep(NA, ncol(F1_mat))
names(labels_matched) <- rownames(F1_mat_trans)
labels_matched[as.character(labels_matched_flipped)] <- as.numeric(names(labels_matched_flipped))
}
# precision, recall, F1 score, and number of cells for each matched cluster
pr <- re <- F1 <- n_cells_matched <- rep(NA, ncol(F1_mat))
names(pr) <- names(re) <- names(F1) <- names(n_cells_matched) <- names(labels_matched)
for (i in 1:ncol(F1_mat)) {
# set to 0 if no matching cluster (too few detected clusters); use character names
# for row and column indices in case subsampling completely removes some clusters
pr[i] <- ifelse(is.na(labels_matched[i]), 0, pr_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
re[i] <- ifelse(is.na(labels_matched[i]), 0, re_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
F1[i] <- ifelse(is.na(labels_matched[i]), 0, F1_mat[as.character(labels_matched[i]), names(labels_matched)[i]])
n_cells_matched[i] <- sum(clus_algorithm == labels_matched[i], na.rm = TRUE)
}
# means across populations
mean_pr <- mean(pr)
mean_re <- mean(re)
mean_F1 <- mean(F1)
mean_pr
pr
re
F1
F1_mat
